metrics-generator: cypher-metrics
snapshot-metrics:
  global:
    - metric: _before_classes
      query: |
        MATCH (b:class)
        WHERE b.name STARTS WITH 'before'
        RETURN count(b) AS metric
    - metric: _before_concrete_classes
      query: |
        MATCH (b:class)
        WHERE b.name STARTS WITH 'before' AND b.type = 'class'
        RETURN count(b) AS metric
    - metric: _before_abstracts_classes
      query: |
        MATCH (b:class)
        WHERE b.name STARTS WITH 'before' AND (b.type = 'abstract' OR b.type = 'interface')
        RETURN count(b) AS metric
    - metric: _after_classes
      query: |
        MATCH (b:class)
        WHERE b.name STARTS WITH 'after'
        RETURN count(b) AS metric
    - metric: _after_abstracts_classes
      query: |
        MATCH (b:class)
        WHERE b.name STARTS WITH 'after' AND (b.type = 'abstract' OR b.type = 'interface')
        RETURN count(b) AS metric
    - metric: _after_concrete_abstracts
      query: |
        MATCH (b:class)
        WHERE b.name STARTS WITH 'after' AND b.type = 'class'
        RETURN count(b) AS metric
    - metric: deleted_classes
      query: |
        MATCH (b:class)
        WHERE b.name STARTS WITH 'before'
        AND NOT EXISTS {
            MATCH (a:class)
            WHERE a.name = 'after' + substring(b.name, 6)
        }
        RETURN count(b) AS metric
    - metric: added_classes
      query: |
        MATCH (a:class)
        WHERE a.name STARTS WITH 'after'
        AND NOT EXISTS {
          MATCH (b:class)
          WHERE b.name = 'before' + substring(a.name, 5)
        }
        RETURN count(a) AS metric
    - metric: deleted_concrete_classes
      query: |
        MATCH (b:class)
        WHERE b.name STARTS WITH 'before' AND b.type = 'class'
        AND NOT EXISTS {
          MATCH (a:class)
          WHERE a.name = 'after' + substring(b.name, 6) 
            AND a.type = 'class'
        }
        RETURN count(b) AS metric
    - metric: added_concrete_classes
      query: |
        MATCH (a:class)
        WHERE a.name STARTS WITH 'after' AND a.type = 'class'
        AND NOT EXISTS {
          MATCH (b:class)
          WHERE b.name = 'before' + substring(a.name, 5)
            AND b.type = 'class'
        }
        RETURN count(a) AS metric
    - metric: deleted_abstracts_classes
      query: |
        MATCH (b:class)
        WHERE b.name STARTS WITH 'before' AND (b.type = 'abstract' OR b.type = 'interface')
        AND NOT EXISTS {
          MATCH (a:class)
          WHERE a.name = 'after' + substring(b.name, 6) AND (a.type = 'abstract' OR a.type = 'interface')
        }
        RETURN count(b) AS metric
    - metric: added_abstracts_classes
      query: |
        MATCH (a:class)
        WHERE a.name STARTS WITH 'after' AND (a.type = 'abstract' OR a.type = 'interface')
        AND NOT EXISTS {
          MATCH (b:class)
          WHERE b.name = 'before' + substring(a.name, 5) AND (b.type = 'abstract' OR b.type = 'interface')
        }
        RETURN count(a) AS metric
    - metric: base_class_change
      query: |
        MATCH (a:class)-[r1]->(b:class)
        WHERE a.name STARTS WITH 'after'
        AND b.name STARTS WITH 'after'
        AND EXISTS {
          MATCH (c:class), (d:class)
          WHERE c.name = 'before' + substring(a.name, 5)
          AND d.name = 'before' + substring(b.name, 5)
          AND NOT EXISTS {
            MATCH (c)-[r2]->(d)
          }
        }
        RETURN count(r1) AS metric
    - metric: added_relationships
      query: |
        MATCH (a:class)-[r]->(b:class)
        WHERE a.name STARTS WITH 'after'
        AND b.name STARTS WITH 'after'
        AND NOT EXISTS {
          MATCH (c:class)-[r1]->(d:class)
          WHERE c.name = 'before' + substring(a.name, 5)
            AND d.name = 'before' + substring(b.name, 5)
        }
        RETURN count(r) AS metric
    - metric: deleted_relationships
      query: |
        MATCH (c:class)-[r]->(d:class)
        WHERE c.name STARTS WITH 'before'
        AND d.name STARTS WITH 'before'
        AND NOT EXISTS {
          MATCH (a:class)-[r1]->(b:class)
          WHERE a.name = 'after' + substring(c.name, 6)
            AND b.name = 'after' + substring(d.name, 6)
        }
        RETURN count(r) AS metric
    - metric: inheritance_to_composition
      query: |
        MATCH (a:class)-[r]->(b:class)
        WHERE a.name STARTS WITH 'after'
        AND b.name STARTS WITH 'after'
        AND r.name = 'composition'
        AND EXISTS {
          MATCH (c:class)-[r1]->(d:class)
          WHERE c.name = 'before' + substring(a.name, 5)
            AND d.name = 'before' + substring(b.name, 5)
            AND r1.name = 'inheritance'
        }
        RETURN count(r) AS metric
    - metric: composition_to_inheritance
      query: |
        MATCH (a:class)-[r]->(b:class)
        WHERE a.name STARTS WITH 'after'
        AND b.name STARTS WITH 'after'
        AND r.name = 'inheritance'
        AND EXISTS {
          MATCH (c:class)-[r1]->(d:class)
          WHERE c.name = 'before' + substring(a.name, 5)
            AND d.name = 'before' + substring(b.name, 5)
            AND r1.name = 'composition'
        }
        RETURN count(r) AS metric
    - metric: concrete_to_abstract
      query: |
        MATCH (a:class)
        WHERE a.name STARTS WITH 'after' AND (a.type = 'abstract' OR a.type = 'interface')
        AND EXISTS {
          MATCH (b:class)
          WHERE b.name = 'before' + substring(a.name, 5) AND b.type = 'class'
        }
        RETURN count(a) AS metric
    - metric: abstract_to_concrete
      query: |
        MATCH (a:class)
        WHERE a.name STARTS WITH 'after' AND a.type = 'class'
        AND EXISTS {
          MATCH (b:class)
          WHERE b.name = 'before' + substring(a.name, 5) AND (b.type = 'abstract' OR b.type = 'interface')
        }
        RETURN count(a) AS metric
    - metric: number_of_classes_that_change_package
      query: |
        MATCH (a:class)
        WHERE a.name STARTS WITH 'after'
        WITH a, substring(a.name, 5) AS base_name, substring(a.package, 6) AS pkg_after
        WITH a, base_name, pkg_after, 'before' + base_name AS before_name
        MATCH (b:class {name: before_name})
        WITH a, b, pkg_after, substring(b.package, 7) AS pkg_before
        WHERE pkg_after <> pkg_before
        RETURN count(a) AS metric
    - metric: _before_methods
      query: |
        MATCH (b:class)-[:HAS_METHOD]->(m:method)
        WHERE b.name STARTS WITH 'before'
        RETURN count(m) AS metric
    - metric: _after_methods
      query: |
        MATCH (b:class)-[:HAS_METHOD]->(m:method)
        WHERE b.name STARTS WITH 'after'
        RETURN count(m) AS metric
    - metric: added_methods
      query: |
        MATCH (a:class)-[:HAS_METHOD]->(m:method)
        WHERE a.name STARTS WITH 'after'
        AND NOT EXISTS {
          MATCH (b:class)-[:HAS_METHOD]->(m1:method)
          WHERE b.name = 'before' + substring(a.name, 5)
            AND substring(m1.name, 6) = substring(m.name, 5)
        }
        RETURN count(m) AS metric
    - metric: deleted_methods
      query: |
        MATCH (b:class)-[:HAS_METHOD]->(m:method)
        WHERE b.name STARTS WITH 'before'
        AND NOT EXISTS {
          MATCH (a:class)-[:HAS_METHOD]->(m1:method)
          WHERE a.name = 'after' + substring(b.name, 6)
            AND substring(m1.name, 5) = substring(m.name, 6)
        }
        RETURN count(m) AS metric
    - metric: added_public_methods
      query: |
        MATCH (a:class)-[:HAS_METHOD]->(m:method)
        WHERE a.name STARTS WITH 'after' AND m.visibility = 'public'
        AND NOT EXISTS {
          MATCH (b:class)-[:HAS_METHOD]->(m1:method)
          WHERE b.name = 'before' + substring(a.name, 5)
            AND substring(m1.name, 6) = substring(m.name, 5)
        }
        RETURN count(m) AS metric
    - metric: private_to_public_methods
      query: |
        MATCH (a:class)-[:HAS_METHOD]->(m:method)
        WHERE a.name STARTS WITH 'after' AND m.visibility = 'public'
        AND EXISTS {
          MATCH (b:class)-[:HAS_METHOD]->(m1:method)
          WHERE b.name = 'before' + substring(a.name, 5)
            AND substring(m1.name, 6) = substring(m.name, 5)
            AND (m1.visibility = 'private' OR m1.visibility = 'protected')
        }
        RETURN count(m) AS metric
    - metric: hidden_factor_methods
      query: |
        MATCH (a:method)
        WHERE a.visibility IN ['private','protected']
        WITH count(a) AS hidden
        MATCH (b:method)
        WITH hidden, count(b) AS total
        RETURN CASE WHEN total = 0 THEN 0.0 ELSE toFloat(hidden) / toFloat(total) END AS metric;
  per-class:
    - metric: abstracts_deps_count
      query: |
        MATCH (c:class {name: $class_name})-[r]->(dependent:class)
        WHERE dependent.type = 'abstract' OR dependent.type = 'interface'
        RETURN count(r) AS metric
    - metric: concrete_deps_count
      query: |
        MATCH (c:class {name: $class_name})-[r]->(dependent:class)
        WHERE dependent.type = 'class'
        RETURN count(r) AS metric
    - metric: afferent_count
      query: |
        MATCH (external:class)-[r]->(c:class {name: $class_name})
        RETURN count(r) AS metric
    - metric: efferent_count
      query: |
        MATCH (c:class {name: $class_name})-[r]->(external:class)
        RETURN count(r) AS metric
    - metric: instability_class
      query: |
        MATCH (c:class {name: $class_name}) // Nodo actual
        OPTIONAL MATCH (c)-[r]->(external:class) // Relación saliente
        WITH c, count(r) AS salidas
        OPTIONAL MATCH (external2:class)-[r2]->(c) // Relación entrante
        WITH salidas, count(r2) AS entradas
        RETURN
          CASE 
            WHEN (salidas + entradas) = 0 THEN 0
            ELSE toFloat(salidas) / toFloat(salidas + entradas)
          END AS metric
  per-package:
    - metric: nodes
      query: |
        MATCH (n:class)
        WHERE n.package = $package_name
        RETURN count(n) AS metric
    - metric: classes
      query: |
        MATCH (c:class)
        WHERE c.package = $package_name AND c.type = 'class'
        RETURN count(c) AS metric
    - metric: abstracts
      query: |
        MATCH (a:class)
        WHERE a.package = $package_name AND a.type = 'abstract' 
        RETURN count(a) AS metric
    - metric: interfaces
      query: |
        MATCH (i:class)
        WHERE i.package = $package_name AND i.type = 'interface'
        RETURN count(i) AS metric
    - metric: efferent
      query: |
        MATCH (c:class)
        WHERE c.package = $package_name
        MATCH (c)-[r]->(external:class)
        WHERE external.package <> $package_name
        RETURN count(r) AS metric
    - metric: afferent
      query: |
        MATCH (c:class)
        WHERE c.package = $package_name
        MATCH (external:class)-[r]->(c)
        WHERE external.package <> $package_name
        RETURN count(r) AS metric
    - metric: instability
      query: |
        MATCH (c:class)
        WHERE c.package = $package_name
        OPTIONAL MATCH (c)-[r]->(external)
        WHERE external.package <> $package_name
        WITH count(r) AS total_salidas
        OPTIONAL MATCH (external2)-[r2]->(c)
        WHERE external2.package <> $package_name
        WITH total_salidas, count(r2) AS total_entradas
        RETURN
          CASE 
            WHEN (total_salidas + total_entradas) = 0 THEN 0
            ELSE toFloat(total_salidas) / toFloat(total_salidas + total_entradas)
          END AS metric
delta-metrics:
  global:
  per-class:
  per-package: